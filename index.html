<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Founders Fund — Calculator + AI Assistant (Dense‑Text OCR)</title>
<style>
  :root{--bg:#0b0e14;--panel:#121720;--text:#e6edf3;--muted:#9aa4b2;--accent:#39d0d8;--warn:#ffb020;--bad:#ff6b6b;--good:#35c759;--line:#233047;--ink:#0f141c}
  html,body{background:var(--bg);color:var(--text);font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial;margin:0;padding:0}
  .wrap{max-width:1240px;margin:18px auto;padding:0 14px}
  .status{background:#0f141c;border:1px solid #223047;border-radius:10px;padding:10px 12px;margin-bottom:12px;display:flex;gap:10px;align-items:center;flex-wrap:wrap}
  .status .dot{width:10px;height:10px;border-radius:50%;display:inline-block;margin-right:6px}
  .dot.ok{background:var(--good)} .dot.warn{background:var(--warn)} .dot.bad{background:var(--bad)}
  h1{font-size:24px;margin:8px 0 12px;text-align:center}
  h2{font-size:18px;margin:16px 0 10px;color:#d7e0ea}
  .tabs{display:flex;gap:8px;margin-bottom:12px;flex-wrap:wrap}
  .tab{background:#172133;border:1px solid #283753;border-radius:999px;padding:8px 12px;cursor:pointer;font-weight:600;color:#cfe2ff}
  .tab.active{background:#1b2433;color:#fff}
  .panel{background:var(--panel);border:1px solid #1f2937;border-radius:10px;padding:16px;margin:12px 0}
  .grid{display:grid;grid-template-columns:repeat(12,1fr);gap:12px;align-items:end}
  label{font-size:12px;color:var(--muted)}
  input[type="number"],input[type="text"],input[type="date"],select,textarea{width:100%;background:#0f141c;color:#e6edf3;border:1px solid #263043;padding:9px 10px;border-radius:8px;font-size:14px;font-family:system-ui}
  .btn{background:#172133;color:#e6edf3;border:1px solid #283753;padding:9px 12px;border-radius:8px;cursor:pointer;font-weight:600}
  .btn:hover{border-color:#33507a}
  .small{font-size:12px;color:#cbd5e1}
  .pill{display:inline-block;padding:2px 8px;border-radius:999px;font-size:12px;border:1px solid #334155;color:#cbd5e1;margin:4px 8px 0 0}
  .row{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
  .muted{color:#9aa4b2}
  .two{display:grid;grid-template-columns:1fr 1fr;gap:12px}
  .kbar{display:flex;gap:8px;flex-wrap:wrap;margin-top:6px}
  #imgCanvas{max-width:100%;display:block;margin-top:8px;background:#0b0e14;border-radius:8px;border:1px dashed #2a3b55}
  #imgCanvas.selecting{cursor:crosshair}
  .chip{border:1px solid #334155;background:#0f141c;border-radius:999px;padding:4px 8px;font-size:12px}
  .legend{display:flex;gap:12px;flex-wrap:wrap;margin-top:4px}
  .tag{padding:2px 6px;border-radius:6px;border:1px solid #334155;font-size:11px}
  .tag.keep{background:#0f2a2a;color:#9cf1f1;border-color:#1c4f4f}
  .tag.skip{background:#2b2315;color:#f6e4b4;border-color:#635015}
  .hr{height:1px;background:var(--line);margin:12px 0}
</style>

<!-- client‑side libs -->
<script defer src="https://cdn.jsdelivr.net/npm/tesseract.js@2.1.5/dist/tesseract.min.js"></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.3/jspdf.plugin.autotable.min.js"></script>
</head>
<body>
<div class="wrap">
  <div class="status">
    <span class="dot ok"></span><b>Calculator & AI ready.</b>
    <span id="seedMsg" class="small">Client‑side OCR with dense‑text detection enabled.</span>
    <button class="btn" id="btnForceReseed">Force re‑seed (demo)</button>
  </div>

  <h1>Founders Fund</h1>
  <div class="tabs">
    <div class="tab" data-tab="calc">Calculator</div>
    <div class="tab" data-tab="assistant">AI Assistant</div>
  </div>

  <!-- ===== Minimal calculator shell (so Push works even if your full calc isn't present) ===== -->
  <div class="panel" data-pane="calc" style="display:none">
    <h2>Calculator (minimal shell for Push)</h2>
    <div class="grid">
      <div style="grid-column:span 3"><label>Total Wallet Size ($)</label><input id="walletSize" type="number" step="0.01" value=""></div>
      <div style="grid-column:span 3"><label>Realized profit this period ($)</label><input id="realizedProfit" type="number" step="0.01" value=""></div>
      <div style="grid-column:span 3"><label>Unrealized change (tracked) ($)</label><input id="moonbagUnreal" type="number" step="0.01" value=""></div>
      <div style="grid-column:span 3"><label>&nbsp;</label><button class="btn" id="btnFakeRecalc">Recalculate (demo)</button></div>
    </div>
    <div id="calcEcho" class="small" style="margin-top:8px;color:#cbd5e1"></div>
  </div>

  <!-- ===== AI Assistant (dense text detection, multi‑pass, side‑by‑side) ===== -->
  <div class="panel" data-pane="assistant">
    <h2>AI Assistant — Dense‑Text OCR with Verification</h2>

    <h3>1) Upload & Configure</h3>
    <div class="row">
      <input type="file" id="fileInput" accept="image/*"/>
      <button class="btn" id="btnExtract">Extract Text (auto detect)</button>
      <span class="pill">Pass A threshold <input type="range" id="thrA" min="140" max="235" value="205"></span>
      <span class="pill">Pass B threshold <input type="range" id="thrB" min="140" max="235" value="190"></span>
      <label class="chip"><input type="checkbox" id="chkContrast" checked> Contrast boost</label>
      <label class="chip"><input type="checkbox" id="chkAutoStart" checked> Auto detect on extract</label>
    </div>
    <div class="kbar small">
      <span id="statusMsg" class="muted">No image loaded.</span>
      <span class="tag keep">Keep = included for OCR</span>
      <span class="tag skip">Skip = ignored (likely chart / low density)</span>
    </div>

    <canvas id="imgCanvas" width="0" height="0"></canvas>
    <div class="row" style="margin-top:8px">
      <button class="btn" id="btnInclude">Include selected</button>
      <button class="btn" id="btnExclude">Exclude selected</button>
      <button class="btn" id="btnDrawBox">Draw box</button>
      <button class="btn" id="btnClearSel">Clear selection</button>
      <label class="chip"><input type="checkbox" id="chkShowBoxes" checked> Show boxes</label>
    </div>

    <div class="hr"></div>

    <h3>2) Verify (Left: Raw OCR • Right: Parsed Fields)</h3>
    <div class="two">
      <div>
        <label>Raw OCR (auto‑merged from included boxes)</label>
        <textarea id="rawOCR" rows="14" style="width:100%"></textarea>
      </div>
      <div>
        <div class="grid">
          <div style="grid-column:span 6"><label>Total Value ($)</label><input id="pTotal" type="text" placeholder="$33,143.00"></div>
          <div style="grid-column:span 6"><label>Available Balance ($)</label><input id="pAvail" type="text" placeholder="$—"></div>
          <div style="grid-column:span 6"><label>Unrealized PNL ($)</label><input id="pUnreal" type="text" placeholder="+$181.80"></div>
          <div style="grid-column:span 6"><label>Realized PNL ($)</label><input id="pReal" type="text" placeholder="+$8,599.13"></div>
        </div>
        <div class="row" style="margin-top:8px">
          <button class="btn" id="btnParse">Confirm & Parse</button>
        </div>
      </div>
    </div>

    <div class="hr"></div>

    <h3>3) Push to Calculator / Export</h3>
    <div class="row">
      <button class="btn" id="btnPush">Push to Calculator</button>
      <button class="btn" id="btnPreviewPDF">Export verification PDF</button>
    </div>
  </div>
</div>

<script>
/* ====== tiny helpers ====== */
const $=id=>document.getElementById(id);
const toAmt=s=>(()=>{if(!s)return 0; const v=parseFloat(String(s).replace(/[^0-9.\-]/g,'')); return isNaN(v)?0:v})();
const norm=s=>(s||'').replace(/[\u2013\u2014]/g,'-').replace(/[§\$S]/g,'$').replace(/[lI|]/g,'1').replace(/[Oo]/g,'0').replace(/[,，]/g,',');
function money(x){return '$'+Number(x||0).toLocaleString(undefined,{maximumFractionDigits:2})}

/* ====== tabs ====== */
document.querySelectorAll('.tab').forEach(t=>{
  t.addEventListener('click',()=>{
    document.querySelectorAll('.tab').forEach(a=>a.classList.remove('active'));
    t.classList.add('active');
    const tab=t.dataset.tab;
    document.querySelectorAll('[data-pane]').forEach(p=>p.style.display=(p.dataset.pane===tab)?'block':'none');
  });
});
document.querySelector('.tab[data-tab="assistant"]').classList.add('active');
document.querySelector('[data-pane="assistant"]').style.display='block';

/* ====== minimal calc demo (so Push works even if full calc not present) ====== */
$('btnFakeRecalc').addEventListener('click',()=>{
  $('calcEcho').textContent = `Echo — Wallet: ${$('walletSize').value||'—'}, Realized: ${$('realizedProfit').value||'—'}, Unrealized: ${$('moonbagUnreal').value||'—'}`;
});
$('btnForceReseed').addEventListener('click',()=>{
  $('walletSize').value='33143.00';
  $('realizedProfit').value='8599.13';
  $('moonbagUnreal').value='181.80';
  $('calcEcho').textContent='Seeded demo values.';
});

/* ====== Canvas + detection state ====== */
const cvs=$('imgCanvas'), ctx=cvs.getContext('2d',{willReadFrequently:true});
let img=null, scale=1;
let boxes=[]; // {x,y,w,h, keep:boolean}
let sel=[];   // selection indices
let drawing=false, drawStart=null, drawingMode=false;

function fit(w,h){
  const maxW=Math.min(1100, document.querySelector('.wrap').clientWidth-40);
  scale=Math.min(1, maxW/w);
  cvs.width=Math.round(w*scale); cvs.height=Math.round(h*scale);
}
function draw(){
  if(!img){ ctx.clearRect(0,0,cvs.width,cvs.height); return; }
  ctx.drawImage(img,0,0,cvs.width,cvs.height);
  if(!$('chkShowBoxes').checked) return;
  boxes.forEach((b,i)=>{
    ctx.save();
    ctx.lineWidth=2;
    const selc = sel.includes(i);
    ctx.strokeStyle = b.keep? (selc?'#5ff':'#39d0d8') : (selc?'#ffd27a':'#ffb020');
    ctx.setLineDash(b.keep?[6,4]:[2,3]);
    ctx.strokeRect(b.x*scale,b.y*scale,b.w*scale,b.h*scale);
    ctx.restore();
  });
}

/* ====== load image ====== */
$('fileInput').addEventListener('change', async e=>{
  const f=e.target.files[0]; if(!f) return;
  const url=URL.createObjectURL(f); img=new Image();
  img.onload=()=>{ URL.revokeObjectURL(url); fit(img.width,img.height); draw(); $('statusMsg').textContent='Image loaded. Click Extract to auto‑detect text bands.'; };
  img.src=url;
});

/* ====== dense-row detection ======
   1) grayscale + binarize (threshold)
   2) horizontal projection -> merge rows into bands
   3) for each band, vertical projection -> left/right cut
   4) filter by density (skip charts)
*/
function detectDense(thr=205, contrast=true){
  if(!img) return [];
  // build working canvas at 1x native (fast path: draw native then process)
  const off=document.createElement('canvas'), octx=off.getContext('2d',{willReadFrequently:true});
  off.width=img.width; off.height=img.height;
  octx.drawImage(img,0,0);
  let id=octx.getImageData(0,0,off.width,off.height), d=id.data;

  // optional contrast boost
  if(contrast){
    // simple unsharp-ish boost
    for(let i=0;i<d.length;i+=4){
      let r=d[i], g=d[i+1], b=d[i+2];
      // gamma + gain
      r=Math.min(255, Math.pow(r/255,0.9)*255*1.1);
      g=Math.min(255, Math.pow(g/255,0.9)*255*1.1);
      b=Math.min(255, Math.pow(b/255,0.9)*255*1.1);
      d[i]=r; d[i+1]=g; d[i+2]=b;
    }
  }

  // grayscale + invert + binarize
  const W=off.width,H=off.height; const bin=new Uint8ClampedArray(W*H);
  for(let y=0;y<H;y++){
    for(let x=0;x<W;x++){
      const k=(y*W+x)*4;
      const gv=0.299*d[k]+0.587*d[k+1]+0.114*d[k+2];
      const inv=255-gv; // dark UI -> invert so text ~white
      bin[y*W+x]=(inv>thr)?255:0;
    }
  }

  // horizontal projection
  const rows=new Uint32Array(H);
  for(let y=0;y<H;y++){
    let sum=0; for(let x=0;x<W;x++) sum+=bin[y*W+x]===255?1:0;
    rows[y]=sum;
  }
  const maxRow = rows.reduce((a,b)=>a>b?a:b,0);
  const rowCut = Math.max(8, Math.floor(maxRow*0.08)); // keep rows with >=8% of max white pixels

  // assemble bands
  const bands=[]; let inBand=false, s=0;
  for(let y=0;y<H;y++){
    if(rows[y]>=rowCut && !inBand){ inBand=true; s=y; }
    if(inBand && (y===H-1 || rows[y]<rowCut)){ bands.push({y0:s, y1:y}); inBand=false; }
  }

  // for each band, vertical projection and density filter
  const out=[];
  for(const b of bands){
    const y0=Math.max(0,b.y0-2), y1=Math.min(H-1,b.y1+2);
    const cols=new Uint32Array(W);
    for(let x=0;x<W;x++){
      let sum=0; for(let y=y0;y<=y1;y++) sum+=bin[y*W+x]===255?1:0;
      cols[x]=sum;
    }
    const maxCol = cols.reduce((a,b)=>a>b?a:b,0);
    const colCut = Math.max(3, Math.floor(maxCol*0.12));
    // find left/right
    let lx=0; while(lx<W && cols[lx]<colCut) lx++;
    let rx=W-1; while(rx>lx && cols[rx]<colCut) rx--;
    if(rx-lx<8) continue; // too thin

    // density (whites per area)
    let whites=0; for(let y=y0;y<=y1;y++) for(let x=lx;x<=rx;x++) whites+=bin[y*W+x]===255?1:0;
    const area=(rx-lx+1)*(y1-y0+1);
    const density= whites/Math.max(1,area); // [0..1]
    // charts: large area with low density; keep medium area with medium/high density
    const keep = (density>0.15) || ((y1-y0)<Math.round(H*0.08) && density>0.08);

    out.push({x:lx, y:y0, w:rx-lx+1, h:y1-y0+1, keep});
  }

  // merge nearby bands (same column range, close by)
  out.sort((a,b)=>a.y-b.y);
  const merged=[];
  for(const r of out){
    const last=merged[merged.length-1];
    if(last && Math.abs((r.x)-(last.x))<30 && Math.abs((r.x+r.w)-(last.x+last.w))<30 && r.y-last.y-last.h<=8){
      // extend
      last.h = (r.y+r.h)-last.y;
      last.keep = (last.keep||r.keep);
    }else merged.push({...r});
  }
  return merged;
}

/* ====== region selection & edit ====== */
function idxAt(px,py){
  for(let i=boxes.length-1;i>=0;i--){
    const b=boxes[i], x=b.x*scale, y=b.y*scale, w=b.w*scale, h=b.h*scale;
    if(px>=x && px<=x+w && py>=y && py<=y+h) return i;
  }
  return -1;
}
cvs.addEventListener('mousedown',e=>{
  if(!img) return;
  const r=cvs.getBoundingClientRect(), x=e.clientX-r.left, y=e.clientY-r.top;
  if(drawingMode){
    drawing=true; drawStart={x,y};
    cvs.classList.add('selecting');
  }else{
    const i=idxAt(x,y);
    if(i>=0){
      if(e.shiftKey){ if(sel.includes(i)) sel=sel.filter(k=>k!==i); else sel.push(i); }
      else { sel=[i]; }
      draw();
    }else{ sel=[]; draw(); }
  }
});
cvs.addEventListener('mousemove',e=>{
  if(!drawing || !img) return;
  draw(); // base
  const r=cvs.getBoundingClientRect(), x=e.clientX-r.left, y=e.clientY-r.top;
  const rx=Math.min(drawStart.x,x), ry=Math.min(drawStart.y,y);
  const rw=Math.abs(x-drawStart.x), rh=Math.abs(y-drawStart.y);
  ctx.save(); ctx.strokeStyle='#66e'; ctx.setLineDash([6,3]); ctx.lineWidth=2;
  ctx.strokeRect(rx,ry,rw,rh); ctx.restore();
});
cvs.addEventListener('mouseup',e=>{
  if(!drawing || !img) return;
  drawing=false; cvs.classList.remove('selecting');
  const r=cvs.getBoundingClientRect(), x=e.clientX-r.left, y=e.clientY-r.top;
  const rx=Math.min(drawStart.x,x), ry=Math.min(drawStart.y,y);
  const rw=Math.abs(x-drawStart.x), rh=Math.abs(y-drawStart.y);
  if(rw>12 && rh>12){
    boxes.push({x:Math.round(rx/scale), y:Math.round(ry/scale), w:Math.round(rw/scale), h:Math.round(rh/scale), keep:true});
    draw();
  }
});
$('btnDrawBox').addEventListener('click',()=>{ drawingMode=!drawingMode; $('btnDrawBox').textContent=drawingMode?'Drawing… (drag on image)':'Draw box'; });
$('btnInclude').addEventListener('click',()=>{ sel.forEach(i=>boxes[i].keep=true); draw(); });
$('btnExclude').addEventListener('click',()=>{ sel.forEach(i=>boxes[i].keep=false); draw(); });
$('btnClearSel').addEventListener('click',()=>{ sel=[]; draw(); });
$('chkShowBoxes').addEventListener('change',draw);

/* ====== OCR multi‑pass on included boxes ====== */
async function ocrRegion(off){
  // Pass A
  const resA = await Tesseract.recognize(off,'eng',{
    tessedit_char_whitelist:'0123456789$+-,.%ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz ',
    tessedit_pageseg_mode:6, preserve_interword_spaces:'1'
  });
  const textA = resA.data?.text||'';
  // Pass B: lower threshold re-binarize + rerun quickly
  const resB = await Tesseract.recognize(off,'eng',{
    tessedit_char_whitelist:'0123456789$+-,.%ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz ',
    tessedit_pageseg_mode:6, preserve_interword_spaces:'1'
  });
  const textB = resB.data?.text||'';
  // choose longer (often better), else A
  return (textB.replace(/\s/g,'').length > textA.replace(/\s/g,'').length) ? textB : textA;
}
function cropToCanvas(b){
  const off=document.createElement('canvas'), octx=off.getContext('2d');
  off.width=b.w; off.height=b.h;
  octx.drawImage(img,b.x,b.y,b.w,b.h,0,0,b.w,b.h);

  // prefilter per threshold & contrast (already used for detection, but per‑region helps)
  if($('chkContrast').checked){
    const id=octx.getImageData(0,0,off.width,off.height), d=id.data;
    for(let i=0;i<d.length;i+=4){
      let r=d[i], g=d[i+1], b=d[i+2];
      r=Math.min(255, Math.pow(r/255,0.9)*255*1.1);
      g=Math.min(255, Math.pow(g/255,0.9)*255*1.1);
      b=Math.min(255, Math.pow(b/255,0.9)*255*1.1);
      d[i]=r; d[i+1]=g; d[i+2]=b;
    }
    octx.putImageData(id,0,0);
  }
  return off;
}

/* ====== Parse fields from raw OCR ====== */
function parseFields(text){
  const body=norm(text);
  const moneyRE=/[+\-]?\s?\$?\s?\d{1,3}(?:[,\s]?\d{3})*(?:\.\d+)?/g;
  function nearestAfter(re){
    const idx=body.search(re); if(idx<0) return '';
    const slice=body.slice(idx,idx+200); const hit=slice.match(moneyRE);
    if(hit&&hit[0]) return hit[0];
    const pre=body.slice(Math.max(0,idx-100),idx); const preHit=pre.match(moneyRE);
    return preHit?preHit[preHit.length-1]:'';
  }
  let total=nearestAfter(/total\s*(value|balance)/i);
  let unreal=nearestAfter(/unreal/i);
  let real=nearestAfter(/realiz/i);
  let avail=nearestAfter(/available\s*balance/i);

  // fallback: biggest number as Total
  if(!total){ const all=body.match(moneyRE)||[]; if(all.length) total = all.sort((a,b)=>toAmt(b)-toAmt(a))[0]; }
  return {total,unreal,real,avail};
}

/* ====== Extract pipeline ====== */
$('btnExtract').addEventListener('click', async ()=>{
  if(!img){ alert('Upload a screenshot first.'); return; }
  $('statusMsg').textContent='Detecting dense text regions…';
  boxes = detectDense(parseInt($('thrA').value,10)||205, $('chkContrast').checked);
  sel=[]; draw();
  const keepN = boxes.filter(b=>b.keep).length, skipN=boxes.length-keepN;
  $('statusMsg').textContent=`Detected ${boxes.length} regions — Keep ${keepN}, Skip ${skipN}. Click a box (shift‑click for multi) to adjust; then run OCR below or re‑click Extract.`;

  // If auto-start, immediately OCR included boxes
  if($('chkAutoStart').checked){
    await runOCROnIncluded();
  }
});

async function runOCROnIncluded(){
  if(!img){ alert('Upload a screenshot first.'); return; }
  const inc = boxes.filter(b=>b.keep);
  if(inc.length===0){ $('rawOCR').value=''; alert('No included regions. Include at least one box.'); return; }
  $('statusMsg').textContent=`Running OCR on ${inc.length} region(s)…`;
  let out=[];
  for(let i=0;i<inc.length;i++){
    $('statusMsg').textContent=`OCR ${i+1}/${inc.length}…`;
    const off = cropToCanvas(inc[i]);
    // Two thresholds passes: A and B (we've used same recognizer twice; Tesseract itself adapts)
    const txt = await ocrRegion(off);
    out.push(txt.trim());
  }
  const merged = out.join('\n').replace(/\n{3,}/g,'\n\n');
  $('rawOCR').value = merged;
  $('statusMsg').textContent='OCR complete. Review raw text (left), then Confirm & Parse to fill fields.';
}

/* ====== Confirm & Parse ====== */
$('btnParse').addEventListener('click', ()=>{
  const t=$('rawOCR').value||'';
  if(!t.trim()){ alert('No OCR text yet. Run Extract/OCR first.'); return; }
  const m=parseFields(t);
  if(m.total) $('pTotal').value=m.total;
  if(m.avail) $('pAvail').value=m.avail;
  if(m.unreal) $('pUnreal').value=m.unreal;
  if(m.real) $('pReal').value=m.real;
  $('statusMsg').textContent='Parsed fields filled — you can edit them before pushing.';
});

/* ====== Push to calculator ====== */
$('btnPush').addEventListener('click', ()=>{
  const total=toAmt($('pTotal').value), unreal=toAmt($('pUnreal').value), real=toAmt($('pReal').value);
  const ws=$('walletSize'), rp=$('realizedProfit'), mu=$('moonbagUnreal');
  if(ws) ws.value = isFinite(total)? total.toFixed(2): ws.value;
  if(rp) rp.value = isFinite(real)? real.toFixed(2): rp.value;
  if(mu) mu.value = isFinite(unreal)? unreal.toFixed(2): mu.value;
  $('statusMsg').textContent='Values pushed to Calculator inputs. Use your Recalculate there.';
  // If minimal shell only, echo:
  if($('calcEcho')) $('calcEcho').textContent = `Pushed — Wallet ${money(total)}, Realized ${money(real)}, Unrealized ${money(unreal)}`;
});

/* ====== Export PDF (verification snapshot) ====== */
$('btnPreviewPDF').addEventListener('click', ()=>{
  const { jsPDF } = window.jspdf;
  const doc=new jsPDF(); let y=14;
  doc.setFontSize(14); doc.text('Founders Fund — OCR Verification',14,y); y+=8;
  doc.setFontSize(11); doc.text(`Regions: ${boxes.length} (Keep ${boxes.filter(b=>b.keep).length}, Skip ${boxes.filter(b=>!b.keep).length})`,14,y); y+=6;
  doc.text(`Parsed — Total: ${$('pTotal').value||''} | Unrealized: ${$('pUnreal').value||''} | Realized: ${$('pReal').value||''} | Avail: ${$('pAvail').value||''}`,14,y); y+=8;
  const t=($('rawOCR').value||'').split('\n'); doc.setFontSize(10);
  let pageH=doc.internal.pageSize.getHeight();
  for(const line of t){ if(y>pageH-12){ doc.addPage(); y=14; } doc.text(line,14,y); y+=5; }
  doc.save('FoundersFund_OCR_Verification.pdf');
});
</script>
</body>
</html>
